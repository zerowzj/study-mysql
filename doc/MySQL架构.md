



# 1 





# 1 索引

​		索引是一种经过整理的数据结构。索引类似大学图书馆建书目索引，分类排好序，可以提高数据检索的效率；索引已经成为关系型数据库中非常重要的组成部分，可降低数据库的IO成本。

​		索引可以包含一个或多个列的值，如果索引包含多个列的值，则列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列，mysql优化器也会根据这个原则去进行优化；

# 1.1 索引

1. 索引可选择性

   索引选择性越高，索引的价值越高 索引可选择性的计算: show index from t1;后会有一行Cardinality，是不重复记录的预估值（对列去重）。

   使用Cardinality/rows就可以得到可选择率，越接近1，索引越高效,其值介于(0,1]

## 1.1 索引组织表

​		在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（IOT，index organized tabel），或者叫聚簇索引（clustered index）。

- 每张表都必须有一个主键；

- 根据主键的值构造一棵B+树；

- 这课B+树的叶子节点（leaf page）存放所有的记录（row）；

- 非叶子节点（no-leaf page）存放的主键和指针；

  mysql中每个表都有一个聚簇索引，除此之外的表上的每个聚簇索引都是二级索引，又叫辅助索引（secondary index）

> 行数据库表的两大类：
>
> 1. 索引组织表（聚簇索引表）：MySQL默认表结构，表本身就是一个索引，数据按照主键的顺序来进行组织。
> 2. 堆表（普通的堆表，数据块构成）：ORACLE默认表结构，（ORACLE也支持索引组织表，但是默认ORACLE的主键会默认创建索引）插入数据是随机的。



## 1.1 索引类型

1. 索引分类

   物理上聚簇索引和非聚簇索引

2. 

### 1.1.1 聚簇索引

​		在建表时，InnoDB将表结构数据存储在一个B+树中，B+树叫聚簇索引，以聚簇索引构建的表叫聚簇索引表，又称索引组织表。聚集索引页的叶子节点汇总存放着完整的记录，副主索引页中存放着指向叶子的指针。

​		聚集索引是通过将表的主键作为键值来构造B+树的，因为InnoDB存储引擎是通过主键来构造的，所以这需要每一张表都有主键，如果没有显式的指定主键，那么数据库是自动创建主键，聚集索引不仅仅包含索引的键值，还包含了记录所在其他列的值，聚集索引中的记录是根据键值顺序排列的，但是，不是物理排序，而是顺序排序。

1. 聚簇索引构建规则
   - 存在主键的情况下，是用主键来构建聚簇索引
   - 在没有主键的情况下，如果有唯一性非空索引,就用第一个该索引构建
   - 都没有，则开辟一个6字节的隐藏列，用隐藏列构建主键索引
2. 聚簇索引的特点
   - MySQL的表结构由聚簇索引来构建，表结构本身就是索引的一部分
   - 通过表的主键来键值来构造B+树，因为InnoDB存储引擎是一个索引组织表，这意味着每张表都有一个主键，如果没有显示的创建，则InnoDB会创建一个六个字节的主键，聚簇索引不仅仅包含索引的键值，还包含了记录其他列的信息。
   - 聚簇索引是根据键值顺序存放的，然而要特别注意的是这个顺序是指逻辑顺序，而不是物理上的存储顺序。因为如果是物理顺序那么排序开销是不被接受的。
   - 聚簇索引的非叶子结点存储的是<键值，地址>对。地址为指向下一层的指针，innoDB存储引擎通过页在表空间中的偏移量来表示。
   - 创建表如果指定主键，那么会自动以指定的主键进行查询，互联网业务中，大多数的OLTP业务中，都是根据主键来查询数据，同时查询速度也是非常快的。



### 1.1.2 辅助索引

​		辅助索引又称二级索引或非聚簇索引。

​		辅助索引也是B+树，叶子节点存放的是索引列和主键值，不存放其他列信息，若无主键，则存放的是索引列和该表聚簇索引的虚拟主键值。辅助索引是根据索引列的值排序。

1. 聚簇索引和辅助索引的选择
   - 在聚簇索引和辅助索引都存在的时候，优化器倾向于使用聚簇索引，因为聚簇索引可以通过叶子节点找到数据。
   - 通过辅助索引查询记录仅仅只能得到主键值，要查询完整的记录，还需要通过一次聚簇索引查询。（回表）
   - 仅仅当主键值发生改变的时候，需要更新辅助索引。（问题：索引列改变了难道不更新？）
   - 聚簇索引通常比辅助索引的高度要高（辅助索引不保存所有记录，更小，高度更低）。

### 1.1.3 覆盖索引

​		只需通过辅助索引就可以返回数据。

​		一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。也可以称之为实现了索引覆盖。特高频SQL，强烈推荐使用覆盖索引，可以非常大的提高查询效率。

> 回表：通过辅助索引查询得到的记录信息不足，需要回表再通过聚簇索引查询信息。



### 1.1.4 复合索引

​		建立在多个列上的索引。

​		关于复合索引的使用：遵从最左前缀原则。如当复合索引列有3个时，where条件里是a或者a、b或者a、c或者a、b、c时才可用到复合索引，其他查询都不会用到复合索引。

## 1.1 索引优缺点

1. 优点

   - 加快数据检索效率
   - 加速表和表连接效率
   - 可以创建唯一性约束索引，保证数据库表中每一行数据的唯一性

   > 说明：
   >
   > - 索引可以优化DML操作的查询部分。
   > - 索引提供了查询的可控性，全表查询IO不可控。
   > - 索引查询一条数据的IO次数由索引的层数决定。

2. 缺点

   - 索引需要占用更多物理存储空间。
   - 当对表中的数据进行增加、删除和修改的时候，索引也要更新维护，降低了数据维护效率。

   > 说明：
   >
   > - 尽量在表里不要有冗余索引。
   > - 大数据入库时，可以先干掉索引，插入数据，然后重建索引。

3. 索引建议

   -  经常需要搜索的列  
   - 经常用在表连接的列 
   - 经常使用在WHERE子句中的列
   - 经常需要排序的列
   -  作为主键的列，有唯一约束索引



## 1.1 My SQL的ICP

​		ICP即Index Condition Pushdown，称为索引下推

​		ICP技术是在MySQL5.6中引入的一种索引优化技术。它能减少在使用二级索引过滤where条件时的回表次数和减少MySQL Server层和引擎层的交互次数。在索引组织表中，使用二级索引进行回表的代价相比堆表中是要高一些的。

- 当关闭ICP时，index 仅仅是data access 的一种访问方式，存储引擎通过索引回表获取的数据会传递到MySQL Server层进行where条件过滤。
- 当打开ICP时，如果部分where条件能使用索引中的字段，MySQL Server 会把这部分下推到引擎层，可以利用index过滤的where条件在存储引擎层进行数据过滤，而非将所有通过index access的结果传递到MySQL server层进行where过滤。

优化效果：ICP能减少引擎层访问基表的次数和MySQL Server 访问存储引擎的次数,减少io次数，提高查询语句性能。

​		对where中过滤条件的处理，根据索引使用情况分成了三种：index key, index filter, table filter

1. **index key----确定查询范围**

   用于确定SQL查询在索引中的连续范围(起始范围+结束范围)的查询条件，被称之为Index Key。由于一个范围，至少包含一个起始与一个终止，因此Index Key也被拆分为Index First Key和Index Last Key，分别用于定位索引查找的起始，以及索引查询的终止条件。也就是说根据索引来确定扫描的范围。

2. **index filter---索引过滤**

   在使用 index key 确定了起始范围和介绍范围之后，在此范围之内，还有一些记录不符合where 条件，如果这些条件可以使用索引进行过滤，那么就是index filter。也就是说用索引来进行where条件过滤。

3. **table filter---条件过滤**

   where中的条件不能使用索引进行处理的，只能访问table，进行条件过滤了。也就是说各种各样的 where 条件，在进行处理时，分成了上面三种情况，**一种条件会使用索引确定扫描的范围；一种条件可以在索引中进行过滤；一种必须回表进行过滤；**所以所谓的 ICP 技术，其实就是 index filter 技术而已。只不过因为MySQL的架构原因，分成了server层和引擎层，才有所谓的“下推”的说法。所以ICP其实就是实现了index filter技术，将原来的在server层进行的table filter中可以进行index filter的部分，在引擎层面使用index filter进行处理，不再需要回表进行table filter。



# 1 执行计划

## 1.1 语法

MySQL 使用 explain + sql 语句查看 执行计划，该执行计划不一定完全正确但是可以参考。

```sql
EXPLAIN SELECT * FROM user_base WHERE ub_id = 6;
```

## 1.2 分析

​		首先要查看table对应的表，在真实环境中，可能存在多个联合查询，分析时需要明确是哪张表查询出现性能瓶颈。

​		然后是查看type对应的值，第三个是possible-keys，第四个key，第五个key_len，第六个Extra

type指的是查询的类型，分为全表扫描和索引扫描。全表扫描是低效的。索引扫描又分为几个级别，包含辅助索引扫描和聚集索引扫描，各个级别不一样，性能也不一样。

1. **id**

   select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序。三种情况：

   - id相同：执行顺序由上至下
   - id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
   - id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行

2. **select_type**

   查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询

   - SIMPLE

     简单的select查询，查询中不包含子查询或者union。明白

   - PRIMARY

     查询中包含任何复杂的子部分，最外层查询则被标记为primary。

   - SUBQUERY

     在select 或 where列表中包含了子查询。

   - DERIVED

     在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在零时表里。

   - UNION

     若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived。

   - UNION RESULT

     从union表获取结果的select。

3. table

4.  

5. **type**

   访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：

   ```sql
   system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
   ```

   - system

     表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计。

   - const

     表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const。

   - eq_ref

     唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。

   - ref

     非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。

   - range

     只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、<、>、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引

   - index

     遍历索引，只查询索引列，index与ALL区别为index类型只遍历索引树。这通常为ALL快，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）

   - ALL

     全表扫描，没使用到索引，遍历全表以找到匹配的行

   

6. **possible_key**

   查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用

7. **key**

   实际使用的索引，如果为NULL，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅出现在key列表中。

8. **key_len**

   索引长度，

9. ref

   连接匹配条件，

10. **rows**

    返回估算的结果集数目，注意这并不是一个准确值。

11. filterd

12. Extra

    不适合在其他字段中显示，但是十分重要的额外信息。

    - Using index：使用覆盖索引
    - Using where：
    - Using filesort
    - Using temporary
    - Using join buffer (Block Nested Loop)