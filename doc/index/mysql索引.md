

# 一. MySQL索引

1. 索引可选择性

   索引选择性越高，索引的价值越高 索引可选择性的计算: show index from t1;后会有一行Cardinality，是不重复记录的预估值（对列去重）。

   使用Cardinality/rows就可以得到可选择率，越接近1，索引越高效,其值介于(0,1]

## 3.1 索引是什么

​		索引是一种经过整理的数据结构。索引类似大学图书馆建书目索引，分类排好序，可以提高数据检索的效率；索引已经成为关系型数据库中非常重要的组成部分，可降低数据库的IO成本。

​		索引可以包含一个或多个列的值，如果索引包含多个列的值，则列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列，MySQL优化器也会根据这个原则去进行优化。

​		索引优缺点

1. 优点

   - 加快数据检索效率
   - 加速表和表连接效率
   - 可以创建唯一性约束索引，保证数据库表中每一行数据的唯一性

   > 说明：
   >
   > - 索引可以优化DML操作的查询部分。
   > - 索引提供了查询的可控性，全表查询IO不可控。
   > - 索引查询一条数据的IO次数由索引的层数决定。

2. 缺点

   - 索引需要占用更多物理存储空间。
   - 当对表中的数据进行增加、删除和修改的时候，索引也要更新维护，降低了数据维护效率。

   > 说明：
   >
   > - 尽量在表里不要有冗余索引。
   > - 大数据入库时，可以先干掉索引，插入数据，然后重建索引。

## 3.2 索引组织表

​		在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（IOT，index organized table），或者叫聚簇索引（clustered index）。

- 每张表都必须有一个主键；

- 根据主键的值构造一棵B+树；

- 这课B+树的叶子节点（leaf page）存放所有的记录（row）；

- 非叶子节点（no-leaf page）存放的主键和指针；

  mysql中每个表都有一个聚簇索引，除此之外的表上的每个聚簇索引都是二级索引，又叫辅助索引（secondary index）

> 行数据库表的两大类：
>
> 1. 索引组织表（聚簇索引表）：MySQL默认表结构，表本身就是一个索引，数据按照主键的顺序来进行组织。
> 2. 堆表（普通的堆表，数据块构成）：ORACLE默认表结构，（ORACLE也支持索引组织表，但是默认ORACLE的主键会默认创建索引）插入数据是随机的。



## 3.3 索引类型

1. 索引分类

   - 聚簇索引
   - 辅助索引（二级索引或非聚簇索引）

2. 1231

   - 主键索引
   - 唯一索引
   - 复合索引

   

### 1.1.1 聚簇索引

​		在建表时，InnoDB将表结构数据存储在一个B+树中，B+树叫聚簇索引，以聚簇索引构建的表叫聚簇索引表，又称索引组织表。聚集索引页的叶子节点汇总存放着完整的记录，副主索引页中存放着指向叶子的指针。

​		聚集索引是通过将表的主键作为键值来构造B+树的，因为InnoDB存储引擎是通过主键来构造的，所以这需要每一张表都有主键，如果没有显式的指定主键，那么数据库是自动创建主键，聚集索引不仅仅包含索引的键值，还包含了记录所在其他列的值，聚集索引中的记录是根据键值顺序排列的，但是，不是物理排序，而是顺序排序。

1. 聚簇索引构建规则
   - 存在主键的情况下，是用主键来构建聚簇索引。
   - 在没有主键的情况下，如果有唯一性非空索引，就用第一个该索引构建。
   - 都没有，则开辟一个6字节的隐藏列，用隐藏列构建主键索引。
2. 聚簇索引的特点
   - MySQL的表结构由聚簇索引来构建，表结构本身就是索引的一部分
   - 通过表的主键来键值来构造B+树，因为InnoDB存储引擎是一个索引组织表，这意味着每张表都有一个主键，如果没有显示的创建，则InnoDB会创建一个六个字节的主键，聚簇索引不仅仅包含索引的键值，还包含了记录其他列的信息。
   - 聚簇索引是根据键值顺序存放的，然而要特别注意的是这个顺序是指逻辑顺序，而不是物理上的存储顺序。因为如果是物理顺序那么排序开销是不被接受的。
   - 聚簇索引的非叶子结点存储的是<键值，地址>对。地址为指向下一层的指针，InnoDB存储引擎通过页在表空间中的偏移量来表示。
   - 创建表如果指定主键，那么会自动以指定的主键进行查询，互联网业务中，大多数的OLTP业务中，都是根据主键来查询数据，同时查询速度也是非常快的。



### 1.1.2 辅助索引

​		辅助索引又称二级索引或非聚簇索引。

​		辅助索引也是B+树，叶子节点存放的是索引列和主键值，不存放其他列信息，若无主键，则存放的是索引列和该表聚簇索引的虚拟主键值。辅助索引是根据索引列的值排序。

1. 聚簇索引和辅助索引的选择
   - 在聚簇索引和辅助索引都存在的时候，优化器倾向于使用聚簇索引，因为聚簇索引可以通过叶子节点找到数据。
   - 通过辅助索引查询记录仅仅只能得到主键值，要查询完整的记录，还需要通过一次聚簇索引查询。（回表）
   - 仅仅当主键值发生改变的时候，需要更新辅助索引。（问题：索引列改变了难道不更新？）
   - 聚簇索引通常比辅助索引的高度要高（辅助索引不保存所有记录，更小，高度更低）。

### 1.1.3 覆盖索引

​		只需通过辅助索引就可以返回数据。

​		一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。也可以称之为实现了索引覆盖。特高频SQL，强烈推荐使用覆盖索引，可以非常大的提高查询效率。

> 回表：通过辅助索引查询得到的记录信息不足，需要回表再通过聚簇索引查询信息。



### 1.1.4 复合索引

​		建立在多个列上的索引。

​		关于复合索引的使用：遵从最左前缀原则。如当复合索引列有3个时，where条件里是a或者a、b或者a、c或者a、b、c时才可用到复合索引，其他查询都不会用到复合索引。



## 3.4 索引使用

### 1.1.1 使用建议

-  经常需要搜索的列  
-  经常用在表连接的列 
-  经常使用在WHERE子句中的列
-  经常需要排序的列
-  作为主键的列，有唯一约束索引

### 1.1.1 索引可选择性

​		索引选择性越高，索引的价值越高。索引可选择性的计算使用语句show index from table，会有一列Cardinality，该列表示不重复记录的预估值（对列去重）。

​		使用Cardinality/rows就可以得到可选择率，越接近1，索引越高效,其值介于(0,1]

### 1.1.1 优化原则

1. 避免类型隐式转换

   ​		当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。

   ​		数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。

   > 注意：int转varchar类型转换索引失效，varchar转int类型转索引不失效。

2. 使用最左匹配原则

   如果建的是联合索引，要遵循最左前缀法则。复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。

3. 不在索引列上做任何操作

   保持索引为独立列，不要用函数和运算操作包括计算、使用函数、自动或收到进行类型转换等。

4. union、in、or都能够命中索引，建议使用in。



## 1.1 MySQL的优化

### 1.1.1 索引下推

​		ICP即Index Condition Pushdown，称为索引下推

​		ICP技术是在MySQL5.6中引入的一种索引优化技术。它能减少在使用二级索引过滤where条件时的回表次数和减少MySQL Server层和引擎层的交互次数。在索引组织表中，使用二级索引进行回表的代价相比堆表中是要高一些的。

- 当关闭ICP时，index 仅仅是data access 的一种访问方式，存储引擎通过索引回表获取的数据会传递到MySQL Server层进行where条件过滤。
- 当打开ICP时，如果部分where条件能使用索引中的字段，MySQL Server 会把这部分下推到引擎层，可以利用index过滤的where条件在存储引擎层进行数据过滤，而非将所有通过index access的结果传递到MySQL server层进行where过滤。

优化效果：ICP能减少引擎层访问基表的次数和MySQL Server 访问存储引擎的次数,减少io次数，提高查询语句性能。

​		对where中过滤条件的处理，根据索引使用情况分成了三种：index key, index filter, table filter

1. **index key----确定查询范围**

   用于确定SQL查询在索引中的连续范围(起始范围+结束范围)的查询条件，被称之为Index Key。由于一个范围，至少包含一个起始与一个终止，因此Index Key也被拆分为Index First Key和Index Last Key，分别用于定位索引查找的起始，以及索引查询的终止条件。也就是说根据索引来确定扫描的范围。

2. **index filter---索引过滤**

   在使用 index key 确定了起始范围和介绍范围之后，在此范围之内，还有一些记录不符合where 条件，如果这些条件可以使用索引进行过滤，那么就是index filter。也就是说用索引来进行where条件过滤。

3. **table filter---条件过滤**

   where中的条件不能使用索引进行处理的，只能访问table，进行条件过滤了。也就是说各种各样的 where 条件，在进行处理时，分成了上面三种情况，**一种条件会使用索引确定扫描的范围；一种条件可以在索引中进行过滤；一种必须回表进行过滤；**所以所谓的 ICP 技术，其实就是 index filter 技术而已。只不过因为MySQL的架构原因，分成了server层和引擎层，才有所谓的“下推”的说法。所以ICP其实就是实现了index filter技术，将原来的在server层进行的table filter中可以进行index filter的部分，在引擎层面使用index filter进行处理，不再需要回表进行table filter。

# 二. 执行计划

### 1.1 语法

MySQL 使用 explain + sql 语句查看 执行计划，该执行计划不一定完全正确但是可以参考。

```sql
EXPLAIN SELECT * FROM user_base WHERE ub_id = 6;
```

### 1.2 分析

​		首先要查看table对应的表，在真实环境中，可能存在多个联合查询，分析时需要明确是哪张表查询出现性能瓶颈。

​		然后是查看type对应的值，第三个是possible-keys，第四个key，第五个key_len，第六个Extra

type指的是查询的类型，分为全表扫描和索引扫描。全表扫描是低效的。索引扫描又分为几个级别，包含辅助索引扫描和聚集索引扫描，各个级别不一样，性能也不一样。

1. **id**

   select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序。三种情况：

   - id相同：执行顺序由上至下
   - id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
   - id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行

2. **select_type**

   查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询

   - SIMPLE

     简单的select查询，查询中不包含子查询或者union。

   - PRIMARY

     查询中包含任何复杂的子部分，最外层查询则被标记为primary。

   - SUBQUERY

     在select 或 where列表中包含了子查询。

   - DERIVED

     在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在零时表里。

   - UNION

     若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived。

   - UNION RESULT

     从union表获取结果的select。

3. table

4.  partitions

5. **type**

   访问类型，SQL查询优化中一个很重要的指标，结果值从好到坏依次是：

   ```sql
   system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
   ```

   - system

     表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计。

   - const

     表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const。

   - eq_ref

     唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。

   - ref

     非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。

   - range

     只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、<、>、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引

   - index

     遍历索引，只查询索引列，index与ALL区别为index类型只遍历索引树。这通常为ALL快，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）

   - ALL

     全表扫描，没使用到索引，遍历全表以找到匹配的行

   

6. **possible_key**

   查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用

7. **key**

   实际使用的索引，如果为NULL，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅出现在key列表中。

8. **key_len**

   索引长度，

9. ref

   连接匹配条件，

10. **rows**

    返回估算的结果集数目，注意这并不是一个准确值。

11. filterd

12. Extra

    不适合在其他字段中显示，但是十分重要的额外信息。

    - Using index：使用覆盖索引
    - Using where：
    - Using filesort
    - Using temporary
    - Using join buffer (Block Nested Loop)



# 五. SQL优化器原理

1. 查询优化器是什么

   数据库主要由三部分组成，分别是解析器、优化器和执行引擎。其中优化器是数据库中用于把关系表达式转换成执行计划的核心组件，很大程度上决定了一个系统的性能。

   ![img](https://pic3.zhimg.com/80/v2-6c98f34b8d88cdf590cedfe8b52b9c28_720w.jpg)

2. 查询优化器分类

   查询优化器分为两类：基于规则的优化器（Rule-Based Optimizer，RBO）和基于代价的优化器（Cost-Based Optimizer，CBO）

   - 基于规则的优化器

     ​		根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会变成另外一个关系表达式，同时原有表达式会被裁剪掉，经过一系列转换后生成最终的执行计划。

     ​		RBO中包含了一套有着严格顺序的优化规则，同样一条SQL，无论读取的表中数据是怎么样的，最后生成的执行计划都是一样的。同时，在RBO中SQL写法的不同很有可能影响最终的执行计划，从而影响脚本性能。

   - 基于代价的优化器

     根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型(Cost Model)计算每个执行计划的Cost，从中挑选Cost最小的执行计划。由上可知，CBO中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。

   ​        从上述描述可知，CBO是优于RBO的，原因是RBO是一种只认规则，对数据不敏感的呆板的优化器，而在实际过程中，数据往往是有变化的，通过RBO生成的执行计划很有可能不是最优的。
   事实上目前各大数据库和大数据计算引擎都倾向于使用CBO，例如从Oracle 10g开始，Oracle已经彻底放弃RBO，转而使用CBO；而Hive在0.14版本中也引入了CBO。

3. 查询优化器执行过程

   

4. 1231



